package ro.skypixel.play.dakotaAC.Exploit;

import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.player.PlayerTeleportEvent;
import org.bukkit.scheduler.BukkitRunnable;
import ro.skypixel.play.dakotaAC.Alert;
import ro.skypixel.play.dakotaAC.DakotaAC; // Assuming this is your main plugin class

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

public class Blink implements Listener {

    // Minimum distance considered a "blink" if covered in a single PlayerMoveEvent tick.
    // This value might need tuning based on server performance and testing.
    // 5.0 blocks is a significant jump for one tick.
    private static final double MIN_DISTANCE_FOR_BLINK = 5.0;

    // A set to keep track of players who have recently been legitimately teleported.
    // We'll give them a brief grace period before checking for blinks.
    private final Set<UUID> recentlyTeleported = new HashSet<>();

    private final DakotaAC plugin; // Assuming DakotaAC is your main plugin class instance

    // Constructor to inject the main plugin instance
    public Blink(DakotaAC plugin) {
        this.plugin = plugin;
    }

    /**
     * Handles player movement to detect "blink" like teleports.
     *
     * @param event The PlayerMoveEvent.
     */
    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    public void onPlayerMove(PlayerMoveEvent event) {
        Player player = event.getPlayer();

        // If the player was recently teleported legitimately, skip this check for a moment.
        if (recentlyTeleported.contains(player.getUniqueId())) {
            return;
        }

        Location from = event.getFrom();
        Location to = event.getTo();

        // Basic sanity checks for locations
        if (to == null || from.getWorld() == null || to.getWorld() == null) {
            return;
        }

        // Ensure the movement is within the same world. World changes are handled by PlayerTeleportEvent.
        if (!from.getWorld().equals(to.getWorld())) {
            return;
        }

        // Calculate the distance moved in this single event.
        // Using distanceSquared for a minor performance improvement by avoiding Math.sqrt,
        // so the threshold needs to be squared as well.
        double distanceSquared = from.distanceSquared(to);
        double minDistanceSquared = MIN_DISTANCE_FOR_BLINK * MIN_DISTANCE_FOR_BLINK;

        // We only care about horizontal distance for certain blink types, but for general
        // "teleport-like" movement, total distance is fine.
        // If you want to focus on horizontal blinks, you can set Y coordinates to be the same:
        // from.setY(to.getY()); double horizontalDistanceSquared = from.distanceSquared(to);

        if (distanceSquared >= minDistanceSquared) {
            // Check if the player is flying or gliding, as they can cover larger distances.
            // You might want to have different thresholds or ignore checks for these cases,
            // or ensure that legitimate fast travel (like elytra + fireworks) isn't flagged.
            // For simplicity, this example flags any large jump not covered by PlayerTeleportEvent.
            if (player.isFlying() || player.isGliding()) {
                // Potentially allow larger distances if flying/gliding, or handle separately.
                // For now, we'll still flag it if it's above the general threshold,
                // as blink hacks can be used with flight too.
            }

            Alert.getInstance().alert("Blink", player);
            event.setCancelled(true); // Attempt to rubberband the player
        }
    }

    /**
     * Handles legitimate player teleports to grant a temporary grace period for blink checks.
     *
     * @param event The PlayerTeleportEvent.
     */
    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onPlayerTeleport(PlayerTeleportEvent event) {
        Player player = event.getPlayer();
        final UUID playerUUID = player.getUniqueId();

        // Add player to the recently teleported set
        recentlyTeleported.add(playerUUID);

        // Schedule a task to remove the player from the set after a short delay.
        // 2 ticks should be enough for the client and server to sync after a teleport.
        new BukkitRunnable() {
            @Override
            public void run() {
                recentlyTeleported.remove(playerUUID);
            }
        }.runTaskLater(plugin, 2L); // Use the injected plugin instance
    }
}